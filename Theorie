
DÃ©finir la portÃ©e d'une dÃ©pendance
==================================

Il se peut que la dÃ©pendance que vous voulez ajouter ne soit liÃ©e qu'Ã  un contexte particulier comme l'exÃ©cution des
tests par exemple. C'est le cas de la dÃ©pendance vers JUnit ajoutÃ©e par l'archÃ©type quickstart. En effet, il s'agit
d'un framework de test unitaire et cette bibliothÃ¨que n'a pas Ã  Ãªtre dÃ©ployÃ©e avec votre application en production.

Pour indiquer cela Ã  Maven, les dÃ©pendances sont attachÃ©es Ã  un scope.

Par dÃ©faut ce scope est compile. Ce scope indique que la dÃ©pendance est utilisÃ©e lors de la compilation et sera
accessible dans tous les contextes.

Il existe d'autres scopes. Si je reprends la dÃ©pendance vers JUnit, vous remarquez qu'elle est attachÃ©e au scope test.
Cela veut dire qu'elle n'est accessible que lors de la compilation des tests et leur exÃ©cution.

Il existe aussi des scopes comme provided ou runtime. provided indique que la dÃ©pendance est disponible Ã  la compilation,
mais elle devra Ãªtre fournie par le contexte d'exÃ©cution (le serveur d'application par exemple). Avec runtime en revanche,
la dÃ©pendance n'est pas accessible lors de la compilation, mais elle est disponible Ã  l'exÃ©cution.

Voici un tableau rÃ©capitulatif des scopes, de leur transitivitÃ© et des contextes dans lesquels la dÃ©pendance correspondante
est accessible :


                       Scope       Transitif*       Compilation       Test         ExÃ©cution
                       -----------------------------------------------------------------------

                       compile        âœ“                  âœ“             âœ“               âœ“
                       -----------------------------------------------------------------------
                       test                                            âœ“
                       -----------------------------------------------------------------------
                       provided                          âœ“             âœ“
                       -----------------------------------------------------------------------
                       runtime        âœ“                                âœ“               âœ“

* Si la colonne n'est pas cochÃ©e (âœ“), cela signifie que la transitivitÃ© en tant que sous-dÃ©pendance s'arrÃªte lÃ .
  Je reformule : lorsque vous ajoutez Ã  votre projet une dÃ©pendance vers X et que X a une dÃ©pendance vers Y, si le
  scope de la dÃ©pendance vers Y dans X est :

     * transitif (compile ou runtime), Maven ajoute la dÃ©pendance vers Y Ã  votre projet

     * non transitif (test ou provided), Maven n'ajoute pas la dÃ©pendance vers Y Ã  votre projet

* De maniÃ¨re plus prÃ©cise, si votre projet a une dÃ©pendance vers X et X une dÃ©pendance vers Y, voici le scope qui sera
  donnÃ© par Maven Ã  Y dans votre projet en fonction :

     * du scope de X dans votre projet (colonne de gauche)

     * du scope de Y dans X (ligne d'entÃªte)


              Scope : Xâ†“ â˜ Yâ†’           compile               test            provided            runtime
              -------------------------------------------------------------------------------------------
              compile                  compile                 âˆ…                âˆ…               runtime
              -------------------------------------------------------------------------------------------
              test                     test                    âˆ…                âˆ…                test
              -------------------------------------------------------------------------------------------
              provided                 provided                âˆ…                âˆ…               provided
              -------------------------------------------------------------------------------------------
              runtime                  runtime                 âˆ…                âˆ…               runtime


Utilisation des diffÃ©rents scopes
---------------------------------

Je vais prendre des exemples pour illustrer l'utilisation des scopes dans le module ticket-webapp.

Je vais ajouter les dÃ©pendances suivantes :

junit:junit pour faire des tests unitaires.

javax.servlet:servlet-api pour pouvoir implÃ©menter une servlet

javax.validation:validation-api pour pouvoir utiliser l'API de validation de Bean (JSR 303)

org.apache.bval:bval-jsr comme implÃ©mentation de l'API de validation de Bean (JSR 303)



DÃ©pendance                          Scope                         Explication

junit                               test                          Cette bibliothÃ¨que de test unitaire n'est utile que
                                                                  pour la phase de test

servlet-api                         provided                      J'ai besoin de cette bibliothÃ¨que lors de la compilation
                                                                  pour crÃ©er une Servlet. Cependant, je ne dois pas l'avoir
                                                                  dans les WAR gÃ©nÃ©rÃ©s car elle entrerait en conflit avec
                                                                  celle  fournie par le serveur d'application Java EE lors de
                                                                  l'Ã©xÃ©cution.

validation-api                      compile                       J'ai besoin de cette bibliothÃ¨que lors de la compilation
                                                                  pour utiliser les annotations de cette API dans mes Beans

bval-jsr                            runtime                       Cette bibliothÃ¨que est une implÃ©mentation de l'API de
                                                                  validation de Bean (JSR 303). Mon code ne l'utilise pas
                                                                  directement, donc elle n'est pas nÃ©cessaire Ã  la compilation.
                                                                  Cependant, Ã  l'Ã©xÃ©cution de l'application, une implÃ©mentation
                                                                  de l'API est nÃ©cessaire afin de procÃ©der Ã  la validation des
                                                                  Beans. Cette bibliothÃ¨que est une des implÃ©mentations possibles
                                                                  (il y a aussi org.hibernate:hibernate-validator)

La mise en Å“uvre de l'API de validation de Bean (JSR 303) s'appuie sur le mÃ©canisme de SPI (Service Provider Interfaces).

Ainsi, l'interface de l'API est dÃ©couplÃ©e de l'implÃ©mentation. L'implÃ©mentation est chargÃ©e et Â« cablÃ©e Â» dynamiquement par la JVM Ã  l'exÃ©cution.

AprÃ¨s un mvn clean package, voici donc les bibliothÃ¨ques contenues dans le WAR :

ğŸ—„ ticket-webapp.war
â”œâ”€â”€ ...
â””â”€â”€ ğŸ— WEB-INF
    â””â”€â”€ ğŸ— lib
        â”œâ”€â”€ ğŸ— bval-core-1.1.2.jar  (sous-dÃ©pendance de bval-jsr)
        â”œâ”€â”€ ğŸ— bval-jsr-1.1.2.jar
        â”œâ”€â”€ ğŸ— commons-lang3-3.5.jar (sous-dÃ©pendance de bval-jsr)
        â””â”€â”€ ğŸ— validation-api-1.1.0.Final.jar


GÃ©rer les dÃ©pendances de maniÃ¨re globale
========================================

Vous vous souvenez sÃ»rement que nous avions vu dans le chapitre prÃ©cÃ©dent qu'il est possible de gÃ©rer vos dÃ©pendances de maniÃ¨re globale dans votre projet. Cela se fait grÃ¢ce Ã  la section <dependencyManagement> dans le POM du projet parent.

Vous pouvez ainsi lister toutes les dÃ©pendances utilisables dans les modules dans le projet parent, fixer leurs versions, gÃ©rer les exclusions...

Il ne vous reste plus qu'Ã  ajouter simplement les dÃ©pendances dans vos modules sans (presque) vous soucier du reste. ;)

Vous centralisez et homogÃ©nÃ©isez ainsi la gestion des dÃ©pendances dans votre projet.

Mettons cela en pratique dans le projet ticket :

  ---------





Utiliser une Â« Bill Of Materials Â»
==================================

Il est courant qu'un framework soit composÃ© de plusieurs modules (ex. : SpringÂ®, Apache Strutsâ„¢...). Dans ce cas, au lieu de dÃ©finir, une par une, toutes les dÃ©pendances vers ces modules, il est possible d'utiliser, si elle existe, une Â« Bill Of MaterialsÂ» (BOM). Il s'agit d'un fichier POM spÃ©cifique, mis Ã  disposition par les mainteneurs du framework. Il contient la dÃ©finition des dÃ©pendances fournies par celui-ci.

Pour l'utiliser, il suffit d'importer le POM de cette Â« Bill Of Materials Â» dans la section dependencyManagement de votre projet avec le type pom  et le scope import.

Voici un exemple avec la BOM de Spring :

                                       <project>
                                           ...
                                           <dependencyManagement>
                                               <dependencies>
                                                   <dependency>
                                                       <groupId>org.springframework</groupId>
                                                       <artifactId>spring-framework-bom</artifactId>
                                                       <version>4.3.11.RELEASE</version>
                                                       <type>pom</type>
                                                       <scope>import</scope>
                                                   </dependency>
                                               </dependencies>
                                               ...
                                           </dependencyManagement>
                                           ...
                                       </project>


Versions Snapshot et Release
============================

Il y a un concept fort dans Maven qui s'appelle la reproductibilitÃ© de la construction. Cela veut dire que si vous ne
changez rien et relancez un packaging de votre projet, vous devez obtenir le mÃªme livrable (Ã  quelques deltas prÃ¨s comme
les dates de construction...).

Ceci concerne Ã©galement les dÃ©pendances que vous avez ajoutÃ©es Ã  votre projet. Pour garantir au maximum cette reproductibilitÃ©
avec les dÃ©pendances, il y a un principe de base : une version d'une dÃ©pendance est conventionnellement immuable.
Cela veut dire qu'une fois la version publiÃ©e, elle ne sera plus modifiÃ©e. Si un changement doit intervenir dans le code,
une nouvelle version sera publiÃ©e.

Ces versions s'appellent des releases.

Cependant, il arrive que vous deviez dÃ©pendre d'un Ã©lÃ©ment en cours de dÃ©veloppement. Dans ce cas, la version de cette
Ã©lÃ©ment sera une version snapshot. Cela est prÃ©cisÃ© dans Maven avec le suffixe -SNAPSHOT Ã  la fin de la version.

Une version snapshot peut Ãªtre modifiÃ©e Ã  tout moment et elle fait donc l'objet d'un traitement particulier dans Maven.
